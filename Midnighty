local Players = game:GetService('Players')
local StarterGui = game:GetService('StarterGui')  -- Fixed: CoreGui -> StarterGui
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ContextActionService = game:GetService('ContextActionService')
local VirtualInputManager = game:GetService('VirtualInputManager')
local TweenService = game:GetService("TweenService")

-- Prevent multiple instances
local existingGui = game:GetService("CoreGui"):FindFirstChild("MidnightHubRevive")
if existingGui then
    existingGui:Destroy()
end

-- Create Main GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MidnightHubRevive"
ScreenGui.ResetOnSpawn = false  -- Added to persist GUI
ScreenGui.Parent = game:GetService("CoreGui")

-- Main Frame
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 480, 0, 338)
MainFrame.Position = UDim2.new(0.5, -240, 0.5, -169)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

-- Make frame draggable
local UserInputService = game:GetService("UserInputService")
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
        startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Top Bar
local TopBar = Instance.new("Frame")
TopBar.Name = "TopBar"
TopBar.Size = UDim2.new(1, 0, 0, 40)
TopBar.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
TopBar.BorderSizePixel = 0
TopBar.Parent = MainFrame

-- Title with Rainbow Effect
local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Size = UDim2.new(1, -40, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Midnight Hub | Revive"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 22
Title.Font = Enum.Font.GothamBold
Title.Parent = TopBar

-- Rainbow effect with error handling
local function startRainbowEffect()
    local colors = {
        Color3.fromRGB(254, 0, 0),
        Color3.fromRGB(255, 127, 0),
        Color3.fromRGB(255, 221, 1),
        Color3.fromRGB(0, 200, 0),
        Color3.fromRGB(0, 160, 199),
        Color3.fromRGB(0, 55, 230),
        Color3.fromRGB(129, 16, 210)
    }
    
    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
    local i = 1
    
    while Title.Parent do
        local success, err = pcall(function()
            local tween = TweenService:Create(Title, info, {TextColor3 = colors[i]})
            tween:Play()
            tween.Completed:Wait()
        end)
        
        if not success then
            warn("Rainbow effect error:", err)
            break
        end
        
        task.wait(0.1)
        i = i == #colors and 1 or i + 1
    end
end

coroutine.wrap(startRainbowEffect)()

-- Close Button with improved styling
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 40, 0, 40)
CloseButton.Position = UDim2.new(1, -40, 0, 0)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "Ã—"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 24
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Parent = TopBar

-- Hover effect for close button
CloseButton.MouseEnter:Connect(function()
    TweenService:Create(CloseButton, TweenInfo.new(0.2), {TextColor3 = Color3.fromRGB(255, 0, 0)}):Play()
end)

CloseButton.MouseLeave:Connect(function()
    TweenService:Create(CloseButton, TweenInfo.new(0.2), {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
end)

-- [Rest of the code remains the same but with added error handling]

-- Function to safely invoke remote functions
local function safeInvoke(remote, ...)
    local success, result = pcall(function()
        return remote:InvokeServer(...)
    end)
    
    if not success then
        warn("Failed to invoke remote:", remote.Name, result)
        return nil
    end
    
    return result
end

-- Auto Sell functionality with error handling
AutoSellBtn.MouseButton1Click:Connect(function()
    _G.autoSell = not _G.autoSell
    if _G.autoSell then
        AutoSellBtn.BackgroundColor3 = Color3.fromRGB(0, 255, 127)
        StatusLabel.Text = "Status: Auto Selling"
        
        coroutine.wrap(function()
            while _G.autoSell and task.wait() do
                local player = Players.LocalPlayer
                if not player then continue end
                
                local fishData = player:FindFirstChild("LocalData")
                if not fishData then continue end
                
                local discovered = fishData:FindFirstChild("FishDiscovered")
                if not discovered then continue end
                
                for _, v in pairs(discovered:GetChildren()) do
                    if not _G.autoSell then break end
                    
                    local fishName = tostring(v)
                    local sellFunction = ReplicatedStorage.CloudClientResources.Communication.Functions.SellItem
                    
                    safeInvoke(sellFunction, fishName, 1)
                    task.wait(0.1)  -- Added delay to prevent throttling
                end
            end
        end)()
    else
        AutoSellBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        StatusLabel.Text = "Status: Inactive"
    end
end)

-- Clean up when script is destroyed
ScreenGui.Destroying:Connect(function()
    _G.autoSell = false
    Enabled = false
end)
